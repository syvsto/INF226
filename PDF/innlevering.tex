\documentclass{article}

\usepackage[backend=bibtex, style=verbose-trad2]{biblatex}
\usepackage[utf8]{inputenc}
\bibliography{kilder}

\title{INF226 Obligatory assignment}
\date{2016-10-02}
\author{HÃ¥var Eggereide and Syver Storm-Furru}

\begin{document}
\maketitle
\pagenumbering{gobble}
\newpage
\pagenumbering{arabic}
\tableofcontents
\newpage
\section{Introduction}

  For our obligatory assignment we were tasked with analysing OpenMRS, a medical
  patient journal system. The analysis is performed both using static and
  dynamic code analysis tools (HPE Fortify and FindBugs for static analysis and
  OWASP ZAP for dynamic), as well as a thorough manual run-through of the installation
  process and software usage.

  \paragraph{The goals of software testing}

  It is now common practice  for a developer to adhere to a software architect's
  plan for the development of the software components, and many utilizes
  unit-testing as a supporting tool for developing code without errors. So what
  is then the benefit of having a separate plan and procedure for system testing
  from the view of security?

  Is has been demonstrated with many grim examples during this course and in the
  curriculum texts, the importance of security and the heavy consequences to the
  whole enterprise if it is neglected. The issue is of such a big scope that
  approaching it as just another design or implementation issue fails to
  appreciate the complexity it presents.

  The goal of testing the security as a separate process is to try to map as
  much as possible of the potential security issues and security considerations
  that has to be kept in mind walking thru the process of development. To
  accomplish this it is necessary to approach the software and the architecture
  from the point of view of a agent with malicious intent.

  In the end it is  most likely not possible to make the software completely
  immune to security faults. It's a natural part of security testing to find
  problems where a full repair might not be achievable, it is then also the
  responsibility of the security testing process to develop mitigation plans for
  these vulnerabilities.

  So the goal of security testing is to find, repair and prepare for security
  vulnerabilities.
  
  \paragraph{Static and dynamic analysis}

  Static and dynamic analysis are methods for checking the software for vulnerabilities.
  They are both done using software tools that help the user analyze. Static
  analysis is performed before any code is run, and checks the code base for
  vulnerable code that can be abused. It checks different runtime behaviours,
  both standard and non-standard, in order to find potential backdoors, weak
  code and other vulnerabilities. Dynamic analysis on the other hand is done
  while the application is running, and works a lot like how an actual attacker
  would target the application, performing such things as XSS and SQL incjection
  attacks, as well as monitoring the system runtime, for example performance and
  HTTP requests \autocite[]{VERACODE}.

\newpage
\section{Software involved}
  
\subsection{OpenMRS}

  OpenMRS is, according to the website, the ``world's leading open source
  enterprise electronic medical record system platform'' \autocite[]{OpenMRSAbout}. It is used in
  hospitals and medical facilities all over the world, for example in Nigeria, South Africa, India
  and the United States, and is supported by many different governments, NGOs,
  and both for- and non-profit organisations. The software has a stated goal of
  being usable with no programming knowledge, and to be a common platform for
  which medical informatics efforts in developing can be built.

  \paragraph{Technical Specifications}

  OpenMRS is a client-server platform, with a web front end. It is programmed in
  Java 7, using Tomcat 6 or 7 as the server framework, and MySQL 5.6 as the
  database backend. It also exposes a programming API to users, and is modular
  and extendable.

  \paragraph{Setup}

  The setup process of OpenMRS is quite involved and time consuming when
  attempting to do so on a personal computer, requiring both Tomcat, Java and
  MySQL to be setup. The official documentation is useful, but different parts
  of it uses different versions of e.g. Tomcat, so it can be confusing.
  It also provides install instructions for Windows and Linux distributions
  with Aptitude, but not for OSX or other Linux distributions. 

  As mentioned, OpenMRS doesn't run on the newest version of MySQL (at the time
  of writing MySQL 5.7), and the install instructions do not mention this. The
  process of figuring this out, and of removing and reinstalling a previous
  version of MySQL, proved to be a lengthy detour on an already long road.
  The instructions are also not very specific when noting which files you need
  to run OpenMRS in Tomcat, whether it is the source code, which was difficult
  to build and only return a test suite on a normal compile, a readily packaged
  complete install (which did not work properly), or a .war file that should be
  uploaded to the Tomcat server.

  We first attempted setting up OpenMRS on OSX 10.11, but ran into problems when
  trying to install the correct version of MySQL, and therefore retried in an
  empty virtual machine running Linux (tested with both Lubuntu and Kali Linux).
  Following the install instructions were a lot easier when running Debian based
  distributions containing Aptitude, but we still had to find and install a
  previous version of MySQL. 

  Once everything was installed OpenMRS had some extra setup that was required,
  done through a web interface. This was mostly easy once the correct version of
  MySQL was in place. You were also given a first username and password that
  was, respectively, `admin' and `Admin123'.

  \paragraph{Usage}

  OpenMRS is operated through a web browser, and is centered around a main dashboard that,
  with just the base installation, will give you access to patient journals, as well as
  showing currently active patients. The system also lets you categorize patients/other registered
  in different persons in different categories, easing the process of generating statical analyses.
  The system also lets your register and book future meetings with patients.

\subsection{HPE Fortify}

  Fortify is a code security tool suite, developed by Hewlett-Packard
  Enterprise (HPE). It aims to ``make application security a natural part of the new
  SDLC, enabling time to market by building security in''\autocite[]{Fortify}.
  It contains such tools as WebInspect, a dynamic code analysis tool, and the
  Fortify Static Code Analysis tool. Fortify is a proprietary solution, but is
  available with an academic license for free.

  We ran the Audit Workbench version bundled with Fortify version 16.10.

\paragraph{Audit Workbench}

  Audit Workbench is the tool used to organise the the output of HPE's static
  code analysis software contained in the Fortify package. It is a GUI
  application built on top of Eclipse, specially designed for organising and
  presenting output for the HPE tools. 
  
  The installation process for Audit Workbench was straight-forward, but running
  the program required changing variables for the Eclipse backend, without
  information about how this is done readily available. The software also was a
  large RAM consumer, needing 5 gigabytes of RAM to analyze a relatively large
  project (OpenMRS).

\subsection{FindBugs}

FindBugs is a static analysis tool for scanning java code looking for potential errors in the
implementation. It is distributed under Lesser GNU Public License. The project
originated from the University of Maryland.\autocite[]{FindBugs} It runs on java
1.7 ether initiated from a terminal or you may use a simple GUI which makes it
easier to get familiar with the program. 

We ran FindBugs 3.0.1 for our tests.
 

\subsection{OWASP ZAP}

ZAP is a dynamic analysis tool developed by OWASP, the Open Web Security
Project. The software acts as a proxy between the host computer and a web
application, performing different types of automatic scans, as well as having
tools for manual searches for security vulnerabilities\autocite[]{ZAP}.

%  LocalWords:  HPE

We ran ZAP version 2.5.0 for our tests.

\section{Preliminary results}

\subsection{Visible potential issues}
  During the install process we were on the lookout for potential vulnerabilities that
  were visible to us. Two things stood out:
  1) The program was set up with a static username and password (resepctively `admin'
  and `Admin123'), and we were never prompted to change this. This means that if the system
  installer doesn't notice this is the case, the is a user with administrator priviledges
  available to anyone, which is pretty bad.
  2) The system didn't work with the newest version of MySQL. The latest version it can run (newest 5.6 version)
  has several vulnerabilities, some very serious \autocite[]{CVEDetails}. While some of these
  also are present in newer versions of MySQL, others are not, making the database slightly more vulnerable.

\subsection{Tests of the software tools}

  After we set everything up, we ran a test run of each analysis tool, to make sure
  everything was functioning properly and to find any glaring issues, if any.

\paragraph{Dynamic analysis of the OpenMRS Web GUI}
  
  The initial Quick Start scan of our test setup of the OpenMRS service only had
  the login front page to crawl. This yielded very few results considering this
  is just one page. It found some information about jQuery, ZAP also warned
  about the implementation of the cookie.
  
\paragraph{Audit Workbench report}  

  The first scan yielded a few messages of high concern. The OpenMRS core
  includes unit-test which gives quite a few erroneous warnings concerning
  security risks and more general bad coding practices. 

  There was an error concerning how the cookie was coded which may be
  interesting to look more into.

\paragraph{FindBugs code scan}

  Running the scan seems easy and most of the work is obviously analysing the
  results. The reports might be a bit hard to navigate and there was some
  trouble generating a html report that potentially is more readable. Again the
  unit-test generated false positives.
%  LocalWords:  SDLC
  \newpage

\paragraph{Dependencies}
  \begin{itemize}
    \item MySQL 1.6
    \item tomcat 7
    \item spring framework
    \item jsp
    \item java .. 1.7

\section{Findings and results}

\subsection{Raw data}

\paragraph{Fortify}

  Audit Workbench found 60 critical vulnerablities, as well as 115 issues
  considered highly vulnerable. Following is a list of the categories designated
  by Audit Workbench for these vulnerabilities, as well as the number of
  occurences of each vulnerability and a short explanation.

  The critical vulnerabilities were in the
  following categories:
  
  \begin{itemize}
  \item Command injections (4): The program tries to call an external command
    without validating where the command is from.
  \item Insecure SSL (3): Uses SSL certificates are based on default system
    Cerftificate Authorities, which may be compromised, and sometimes are.
  \item Hardcoded passwords (3): Lets an attacker log in if he or she has access
    to the source code, which in this case means anyone.
  \item Path manipulation (2): The program accesses a file with an filepath that
    can be chosen by the attacker.
  \item Privacy violation (49): The program mishandles confidential information
    in some way or another, for example by writing it to disk.
  \end{itemize}

  The vulnerabilities rated high are as follows:

  \begin{itemize}
  \item Header manipulation with cookies (1): The program doesn't validate data
    in an HTTP request, so cookies can be tampered or spoofed.
  \item Hardcoded encryption key (3): Same issue as with hardcoded passwords.
  \item Log forging (12): The program doesn't validate inputs that get written
    to the log, meaning malicious data could be entered.
  \item Empty passwords (6): The program assigns empty passwords, making it much
    easier to break into the application.
  \item Hardcoded passwords (25): Same issue as with the critcal hardcoded passwords.
  \item Passwords in Configuration File (36): Passwords are stored in plaintext
    in a configuration file, meaning an attacker can get the password by getting
    the file.
  \item Privacy violation (10): Same issue as in the critical privacy violations.
  \item Privacy violation from heap inspection (3): The program stores
    confidential information in strings, which are immutable and thus stored in
    memory until the JVM garbage collector is run (which may not occur for a
    while). 
  \item Race Conditions from Singleton member field (19): The program uses a
    singleton class which takes concurrent connections, meaning data can be
    shared between users.
  \end{itemize}
      
\paragraph{Configuration Files}  

\paragraph{FindBugs}

  The first scan detected 1058 potential bugs. Some of them are from test clases
  and will not be mentioned here.
  
  \begin{itemize}
    \item Correctness
      \item Bad use of return value from method
      \item Masked Field
      \item Null pointer dereference
      \item Questionable use of reference equality rather than calling equals
      \item Superfluous instanceof
    \item Bad practice
      \item Bad use of return value from method
    \item Experimental
    \item Internationalization 
    \item Malicious code vulnerability
    \item Multithreaded code vulnerability
    \item Performance
    \item Security
      \item Potential SQL Problem
        \item Nonconstant string passed to execute or addBatch method on an SQL
          statement (8)
        \item A prepared statement is generated from a nonconstant String (6)
    \item Dodgy code
        
\paragraph{OWASP ZAP}

\end{document}


\paragraph{OWASP ZAP}
A passive run of ZAP returns the following four possible vulnerabilities:

\begin{itemize}
 \item X-Frame-Options header is not included in the HTTP response to protect against
  'ClickJacking' attacks: Considered a medium vulnerability, this
  vulnerability can let unknown sites be loaded inside frames or iframes.
 \item A cookie has been set without the HttpOnly flag: A low vulnerability that
   makes it possible to access the cookie using Javascript. 
 \item Web browser XSS protection not enabled: A low vulnerability where the
   HTTP header X-XSS-Protection isn't set, so that the browser doesn't use it's
   own cross site scripting protection.
 \item X-Content-Type-Options Header missing: Some older browsers try to
   automatically figure out the content type if X-Content-Type-Options is not
   set to 'nosniff', making it possible to do such operations as cross-site
   scripting \autocite[]{XFrameOptions}.

