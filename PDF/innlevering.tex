\documentclass{article}

\usepackage[backend=bibtex, style=verbose-trad2]{biblatex}
\usepackage[utf8]{inputenc}
\bibliography{kilder}

\title{INF226 Obligatory assignment}
\date{2016-10-02}
\author{HÃ¥var Eggereide and Syver Storm-Furru}

\begin{document}
\maketitle
\pagenumbering{gobble}
\newpage
\pagenumbering{arabic}
\tableofcontents
\newpage
\section{Introduction}

  For our obligatory assignment we were tasked with analysing OpenMRS, a medical
  patient journal system. The analysis is performed both using static and
  dynamic code analysis tools (HPE Fortify and FindBugs for static analysis and
  OWASP ZAP for dynamic), as well as a thorough manual run-through of the installation
  process and software usage.

  \paragraph{The goals of software testing}
  \paragraph{Static and dynamic analysis}
  Static and dynamic analysis are methods for checking the software for vulnerabilities.
  They are both done using software tools that help the user analyze. Static
  analysis is performed before any code is run, and checks the code base for
  vulnerable code that can be abused. It checks different runtime behaviours,
  both standard and non-standard, in order to find potential backdoors, weak
  code and other vulnerabilities. Dynamic analysis on the other hand is done
  while the application is running, and works a lot like how an actual attacker
  would target the application, performing such things as XSS and SQL incjection
  attacks, as well as monitoring the system runtime, for example performance and
  HTTP requests \autocite[]{VERACODE}.

\newpage
\section{Software involved}
  
\subsection{OpenMRS}

  OpenMRS is, according to the website, the ``world's leading open source
  enterprise electronic medical record system platform'' \autocite[]{OpenMRSAbout}. It is used in
  hospitals and medical facilities all over the world, for example in Nigeria, South Africa, India
  and the United States, and is supported by many different governments, NGOs,
  and both for- and non-profit organisations. The software has a stated goal of
  being usable with no programming knowledge, and to be a common platform for
  which medical informatics efforts in developing can be built.

  \paragraph{Technical Specifications}

  OpenMRS is a client-server platform, with a web front end. It is programmed in
  Java 7, using Tomcat 6 or 7 as the server framework, and MySQL 5.6 as the
  database backend. It also exposes a programming API to users, and is modular
  and extendable.

  \paragraph{Setup}

  The setup process of OpenMRS is quite involved and time consuming when
  attempting to do so on a personal computer, requiring both Tomcat, Java and
  MySQL to be setup. The official documentation is useful, but different parts
  of it uses different versions of e.g. Tomcat, so it can be confusing.
  It also provides install instructions for Windows and Linux distributions
  with Aptitude, but not for OSX or other Linux distributions. 

  As mentioned, OpenMRS doesn't run on the newest version of MySQL (at the time
  of writing MySQL 5.7), and the install instructions do not mention this. The
  process of figuring this out, and of removing and reinstalling a previous
  version of MySQL, proved to be a lengthy detour on an already long road.
  The instructions are also not very specific when noting which files you need
  to run OpenMRS in Tomcat, whether it is the source code, which was difficult
  to build and only return a test suite on a normal compile, a readily packaged
  complete install (which did not work properly), or a .war file that should be
  uploaded to the Tomcat server.

  We first attempted setting up OpenMRS on OSX 10.11, but ran into problems when
  trying to install the correct version of MySQL, and therefore retried in an
  empty virtual machine running Linux (tested with both Lubuntu and Kali Linux).
  Following the install instructions were a lot easier when running Debian based
  distributions containing Aptitude, but we still had to find and install a
  previous version of MySQL. 

  Once everything was installed OpenMRS had some extra setup that was required,
  done through a web interface. This was mostly easy once the correct version of
  MySQL was in place. You were also given a first username and password that
  was, respectively, `admin' and `Admin123'.

  \paragraph{Usage}

  OpenMRS is operated through a web browser, and is centered around a main dashboard that,
  with just the base installation, will give you access to patient journals, as well as
  showing currently active patients. The system also lets you categorize patients/other registered
  in different persons in different categories, easing the process of generating statical analyses.
  The system also lets your register and book future meetings with patients.

\subsection{HPE Fortify}

  Fortify is a code security tool suite, developed by Hewlett-Packard
  Enterprise (HPE). It aims to ``make application security a natural part of the new
  SDLC, enabling time to market by building security in''\autocite[]{Fortify}.
  It contains such tools as WebInspect, a dynamic code analysis tool, and the
  Fortify Static Code Analysis tool.

  Fortify is a proprietary solution, but is available with an academic license
  for free.

\paragraph{Audit Workbench}

  Audit Workbench is the tool used to organise the the output of HPE's static
  code analysis software contained in the Fortify package. It is a GUI
  application built on top of Eclipse, specially designed for organising and
  presenting output for the HPE tools. 
  
  The installation process for Audit Workbench was straight-forward, but running
  the program required changing variables for the Eclipse backend, without
  information about how this is done readily available. The software also was a
  large RAM consumer, needing 5 gigabytes of RAM to analyze a relatively large
  project (OpenMRS) The software also was a large RAM consumer, needing 5
  gigabytes of RAM to analyze a relatively large project (OpenMRS.)

\subsection{FindBugs}

FindBugs is a tool for scanning java code looking for potential errors in the
implementation. It is distributed under Lesser GNU Public License. The project
originated from the University of Maryland.\autocite[]{FindBugs}

We ran FindBugs 3.0.1 for our tests.
 

\subsection{OWASP ZAP}

ZAP is a dynamic analysis tool developed by OWASP, the Open Web Security
Project. The software acts as a proxy between the host computer and a web
application, performing different types of automatic scans, as well as having
tools for manual searches for security vulnerabilities\autocite[]{ZAP}.

%  LocalWords:  HPE

We ran ZAP version 2.5.0 for our tests.

\section{Preliminary results}

\subsection{Visible potential issues}
  During the install process we were on the lookout for potential vulnerabilities that
  were visible to us. Two things stood out:
  1) The program was set up with a static username and password (resepctively `admin'
  and `Admin123'), and we were never prompted to change this. This means that if the system
  installer doesn't notice this is the case, the is a user with administrator priviledges
  available to anyone, which is pretty bad.
  2) The system didn't work with the newest version of MySQL. The latest version it can run (newest 5.6 version)
  has several vulnerabilities, some very serious \autocite[]{CVEDetails}. While some of these
  also are present in newer versions of MySQL, others are not, making the database slightly more vulnerable.

\subsection{Tests of the software tools}

  After we set everything up, we ran a test run of each analysis tool, to make sure
  everything was functioning properly and to find any glaring issues, if any.

\paragraph{Dynamic analysis of the OpenMRS Web GUI}
  
  The initial Quick Start scan of our test setup of the OpenMRS service only had
  the login front page to crawl. This yielded very few results considering this
  is just one page. It found some information about jQuery, ZAP also warned
  about the implementation of the cookie.

  
\paragraph{Audit Workbench Rapport}  

  The first scan yielded a few messages of high concern. The OpenMRS core
  includes unit-test which gives quite a few erroneous warnings concerning
  security risks and more general bad coding practices. 

  There was an error concerning how the cookie was coded which may be
  interesting to look more into.

\paragraph{FindBugs code scan}

  Running the scan seems easy and most of the work is obviously analysing the
  results. The reports might be a bit hard to navigate and there was some
  trouble generating a html report that potentially is more readable. Again the
  unit-test generated false positives.
%  LocalWords:  SDLC

\section{The Goals of Software Security Testing}

\subsection{Separate testing of Security}

  It is now common practice  for a developer to adhere to a software architect's
  plan for the development of the software components, and many utilizes
  unit-testing as a supporting too for developing code without errors. So what
  is then the benefit of having a separate plan and procedure for system testing
  from the view of security?

  As the stated in the 
\end{document}
